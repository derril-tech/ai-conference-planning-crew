# THE PROJECT BRIEF #

# Project Name #
Conference Planning Crew

# Product Description / Presentation #

Conference Planning Crew — Multi‑Agent AI Build Brief

Project Codename: OrchestrateX
Product description / presentation

OrchestrateX is a multi‑agent conference planning platform that coordinates specialized AI agents to design, staff, budget, schedule, promote, and run conferences end‑to‑end. Agents collaborate to source venues, recruit speakers, negotiate sponsors, draft agendas, manage budgets, run marketing, handle registrations, and operate day‑of logistics—with human‑in‑the‑loop approvals and a complete audit trail. Outputs are grounded in documents, emails, and vendor data via Retrieval‑Augmented Generation (RAG), and every decision is explainable with citations and costs.
What it does:
•	Auto‑generates a feasible plan (date windows, city shortlists, budget, high‑level agenda) from an objective brief.
•	Runs parallel agents: Venue Scout, Speaker Outreach, Sponsorship Manager, Budget Controller, Marketing Ops, Attendee Experience, Logistics & Travel, Risk & Compliance.
•	Builds an agenda with tracks, assigns rooms, estimates capacity, and resolves conflicts with speaker/room constraints.
•	Negotiates sponsor packages with counter‑proposals and inventory (booths, stage time, branding) tracking.
•	Launches campaigns, opens registration, manages tickets/pricing ladders, and monitors funnel KPIs.
•	Operates a live Command Center on event days: session changes, push notifications, staffing tasks, incident runbooks.
Key features:
•	Agent timeline board with checkpoints, dependencies, costs, and confidence bands.
•	Schedule Builder (drag‑and‑drop) with conflict detection and room capacity modeling.
•	Sponsor CRM with package templating, redline suggestions, and deliverables tracker.
•	Budget console with scenario modeling and live variance vs. plan.
•	RAG‑grounded decisions with source snapshots from RFPs, vendor sheets, emails, and contracts.
Why teams love it:
•	Compresses months of planning into weeks by parallelizing expert work safely.
•	Improves sponsor revenue and attendee experience through data‑driven optimization.
•	Keeps humans in control with clear approvals, citations, and cost impact for each decision.
Framework (and why)
LangGraph (orchestration) + LangChain (tools) + RAG (mandatory) with OpenAI + Claude. LangGraph provides deterministic, resumable, checkpointed multi‑agent workflows with human approval gates, ideal for coordinating Venue, Speaker, Sponsor, Budget, Marketing, Logistics, and Risk agents. LangChain standardizes retrievers, tool calling, and tracing. RAG ensures plans and negotiations are grounded in RFPs, rate cards, contracts, and historical conference data. CrewAI can be used for early role prototyping, but production orchestration remains in LangGraph.
1. BACKEND ARCHITECTURE (extensive)
Core services (FastAPI • async SQLAlchemy 2.0 • Pydantic v2):
•	Auth & Tenant: JWT (access/refresh), RBAC (admin, producer, coordinator, finance, sponsor_sales), optional SSO (OIDC/SAML), SCIM.
•	Event Core: events, venues, rooms, tracks, sessions, speakers, sponsors, packages, deliverables, tasks, tickets, attendees.
•	Knowledge & RAG: corpus ingestion (RFPs, vendor PDFs, contracts, emails, briefs), chunking, embeddings (pgvector), citations.
•	Orchestrator (LangGraph): Brief → Plan → Parallel Agents (Venue/Speakers/Sponsors/Budget/Marketing/Logistics/Risk) → HIL gates → Finalize.
•	Calendar & Email Sync: Google/Microsoft Graph connectors for holds, invites, and shared inbox triage.
•	Ticketing & Payments: ticket types, pricing ladders, promo codes; Stripe checkout + webhooks; registration flows.
•	Vendor Connectors: mapping for hotels/venues (RFP portals), A/V, catering, signage, streaming platforms.
•	Budget & Contracts: baseline budget, PO/Invoice lifecycle, contract templates, tracked changes and approvals.
•	Comms & Notifications: WebSockets for live updates; templated emails/SMS/push; announcement queues.
•	Audit & Governance: approvals, versioning, rationale logs, exportable audit trails.
Pipelines (LangGraph subgraphs):
•	Planning: parse brief → city/date shortlist → capacity & budget model → draft tracks.
•	Venue: collect RFPs → compare AV/catering/min spend → negotiate holds → contract redlines → approval.
•	Speakers: source bios → outreach variants → hold times → contract → travel & session assignment.
•	Sponsors: package design → outreach → counter‑proposal loop → deliverables & invoicing.
•	Marketing: persona definition → calendar → creative variants → channel mix → conversion targets.
•	Registration: pricing ladders → open sales → funnel monitoring → churn/save offers.
•	Logistics: staffing plan → vendor tasks → signage/BOM → run‑of‑show → incident runbooks.
•	Post‑event: NPS & session ratings → budget reconciliation → postmortem report with insights.
Data model (PostgreSQL + pgvector highlights):
•	tenants, users, roles, api_keys, oauth_connections
•	events(id, tenant_id, brief_json, city, venue_pref, start/end, status)
•	venues(id, event_id, name, capacity, rooms[], cost_cards jsonb), rooms(id, venue_id, name, seats, features[])
•	tracks(id, event_id, name, color), sessions(id, track_id, room_id, start/end, title, speaker_id, capacity_model jsonb)
•	speakers(id, name, bio, topics[], availability jsonb, contract_uri)
•	sponsors(id, company, tier, packages jsonb, deliverables jsonb, contract_uri, invoices[])
•	attendees(id, event_id, profile jsonb, tickets[], consent_status, checkins[])
•	tickets(id, event_id, type, price, promo_rules jsonb), payments(id, ticket_id, provider, status, amount)
•	tasks(id, event_id, owner_id, agent, state, deps[], due, notes)
•	knowledge_sources(id, url|file, type, snapshot_uri, as_of, license), chunks(id, source_id, text, vector, offsets)
•	runs(id, event_id, graph_version, status, checkpoints jsonb, cost, durations), approvals(id, run_id, gate, actor_id, decision, notes)
•	audit_logs(id, actor, action, target_type, target_id, before/after jsonb, ts)
Connectors:
•	Calendars & Mail: Google Workspace, Microsoft Graph (holds, invites, shared inbox).
•	Ticketing & Payments: Stripe, Eventbrite (optional).
•	Communication: SendGrid/Postmark, Twilio SMS, Slack/Teams for agent alerts.
•	Maps & Travel: Google Maps Places; optional travel APIs for hotel blocks/air (Amadeus).
•	Documents: S3/GCS storage; e‑signature (DocuSign/Adobe) for venue/sponsor contracts.
•	Streaming: Zoom/Webinar/Hopin for virtual/hybrid components.
Runtime: Redis for queues/caching; WebSockets for live events; idempotent workers for outbound sync and contracting.
2. FRONTEND ARCHITECTURE
•	Next.js 14 (App Router), React 18, TypeScript, Tailwind, shadcn/ui.
•	State: React Query for server cache; lightweight Zustand/Context for UI state; optimistic updates.
•	Views: Event Wizard, Agent Timeline (Gantt), Venue Shortlist, Schedule Builder (drag‑drop), Speaker CRM, Sponsor CRM, Budget Console, Registration Dashboard, Command Center.
•	Real‑time: WebSocket updates (agent progress, contract status, ticket sales, incidents) with toasts and activity feed.
•	Routing: /events/:id/{timeline|venues|schedule|speakers|sponsors|budget|registration|command}, /library, /settings.
•	Accessibility: WCAG 2.1 AA; keyboard shortcuts; high‑contrast & print‑friendly views.
3. DESIGN REQUIREMENTS (UI/UX design based on product & industry)
•	Operations‑grade UI with clear hierarchy and compact tables; color‑coded tracks/agents; status chips.
•	Conflict & risk surfacing: time overlaps, over‑capacity, budget overages, missing deliverables.
•	Explainability panels showing rationale, costs, and citations for each agent decision.
•	Mobile‑first controls for on‑site staff (check‑ins, incident playbooks, quick messages).
•	Dark/light themes; smooth micro‑interactions; real‑time counters (sales, check‑ins).
4. CORE INTEGRATIONS
•	OpenAI + Claude via LangChain; LangSmith for tracing (no sensitive content).
•	Calendars/Mail (Google/Microsoft), Slack/Teams, SendGrid/Postmark.
•	Stripe payments; Eventbrite (optional) ticketing; QR check‑in scanner (camera API).
•	S3/GCS for documents; DocuSign/Adobe Sign for contracts.
•	Maps/Places for venue and logistics context; optional travel API for hotel blocks.
5. DELIVERABLES REQUIRED
•	Next.js frontend with all event planning and command‑center modules.
•	FastAPI backend with LangGraph multi‑agent orchestration and RAG services.
•	PostgreSQL schema + pgvector; migrations; seed kits (sample event, venues, speakers, sponsors).
•	Connectors (calendars/email/Stripe/Slack) and file storage; WebSockets for live coordination.
•	Contracting (DocuSign/Adobe) stubs; export PDFs (agenda, deliverables, budgets).
•	Deployment configs (Vercel/Render), env templates, and OpenAPI docs.
6. SUCCESS CRITERIA
•	E2E demo: brief → plan → venue shortlist → speaker outreach → sponsor deals → schedule build → registration → command‑center dry run → postmortem report.
•	All agent decisions include rationale, cost deltas, and citations; approvals captured at defined gates.
•	No double‑booking; room capacities respected; payment webhooks reconcile correctly; audit trail complete.
7. IMPLEMENTATION GUIDELINES
•	Strict schemas (Pydantic/TypeScript) for agents’ inputs/outputs; stable tool interfaces per agent.
•	Deterministic graph nodes; checkpoint after every gate; idempotent retries for external calls.
•	RAG guardrails: store snapshots & hashes for all cited documents; block finalize without citations.
•	Privacy: avoid sensitive content in prompts/traces; redact emails/PII; signed URLs for documents.
•	Rate‑limit & backoff strategies for all connectors; dry‑run mode for outreach/contracting.
8. SECURITY & COMPLIANCE
•	RBAC by role and event; tenant isolation; encryption in transit and at rest; secrets in KMS/Vault.
•	GDPR/CCPA for attendee data; email consent & unsubscribe management; data retention policies.
•	PCI DSS SAQ‑A alignment when using Stripe Checkout (tokenized, no PAN on our servers).
•	AppSec: OWASP ASVS, input validation, request signing for webhooks, dependency pinning.
•	Comprehensive audit logs for decisions, approvals, and outbound communications.
Claude — 5 critical prompts (tailored, prebuilt‑architecture aware)
PROMPT 1 — PROJECT SETUP & ARCHITECTURE
You are extending a prebuilt full‑stack architecture. Confirm folder layout and add the Conference Planning Crew modules. Frontend: Next.js 14 (TypeScript, Tailwind, shadcn/ui, React Query). Backend: FastAPI (async SQLAlchemy 2.0, Pydantic v2, JWT, RBAC). Data: PostgreSQL + pgvector, Redis. Add a LangGraph multi‑agent skeleton (Brief → Plan → Venue/Speakers/Sponsors/Budget/Marketing/Logistics/Risk → HIL gates → Finalize). Provide env templates and Vercel/Render configs without overwriting existing ones.

PROMPT 2 — CORE BACKEND IMPLEMENTATION
Inside the existing FastAPI app, implement services/endpoints for event core (events, venues, rooms, sessions, speakers, sponsors, tickets, attendees), RAG ingestion over RFPs/vendor docs/contracts, agent orchestration with WebSocket updates, and connectors for calendars/email/Stripe/Slack. Extend Pydantic/SQLAlchemy models; add idempotent workers and approval/audit flows.

PROMPT 3 — FRONTEND COMPONENTS & UI
Extend the Next.js UI with Event Wizard, Agent Timeline (Gantt), Venue Shortlist, Schedule Builder (drag‑drop), Speaker & Sponsor CRMs, Budget Console, Registration Dashboard, and Command Center. Maintain WCAG 2.1 AA semantics, design tokens, and real‑time presence.

PROMPT 4 — AI INTEGRATION & FEATURES
Integrate OpenAI + Claude via LangChain for planning, negotiation suggestions, schedule conflict resolution, and sponsor package drafting. Use RAG over briefs, vendor docs, contracts, and emails. Enforce structured outputs: {decisions[], rationale[], citations[], cost_delta, risks[]}. Block finalize if citations are missing; implement HIL approval gates for high‑impact actions.

PROMPT 5 — DEPLOYMENT & E2E DEMO
Provision DB and Redis, run migrations, and seed a demo event (venues, rooms, sample speakers/sponsors, ticket types). Demonstrate end‑to‑end: brief → plan → venue shortlist → outreach → schedule → registration → command‑center dry run → postmortem. Output OpenAPI docs and sample cURL commands for each step; preserve existing configs.




FOLLOW THIS 8 STEP PLAN TO PREPARE THE INFRASTRUCTURE
-----------------------------------------------------

# 🚀 Claude Fullstack Repo Prep – Optimized 8 Step Plan

  
The goal: build an extensive frontend + backend scaffold so Claude Code only has to finish ~20% of the work.  
Each step must be **completed and reviewed** before advancing.
IMPORTANT: YOU ARE BUILDING ONLY THE INFRASTRUCTURE OF THE APPLICATION NOT THE APPLICATION ITSELF !!!.
You are doing the groundwork for the application, including setting up the folder structure, configuration files, and any necessary boilerplate code.
IMPORTANT: the checklist in each step has to be checked off 100% before moving to the next step

---

## STEP 1 — Build the Rich Infrastructure
Create a **deep scaffold** for both frontend and backend so Claude code can recognize the architecture immediately.

- Build a **frontend app shell** with routing, placeholder pages, components, and styling setup.  
- Build a **backend app shell** with API structure, health endpoint, and config in place.  
- Include `REPO_MAP.md`, `API_SPEC.md`, and a draft `CLAUDE.md` in the `docs/` folder.  (create the docs folder if it does not exist)
- Add **TODO markers and folder-level `_INSTRUCTIONS.md`** files so Claude knows exactly where to add logic.

**Deliverables**
- Frontend app shell with routing, placeholder pages, components, and styling setup  
- Backend app shell with API structure, health endpoint, and config  
- `docs/REPO_MAP.md`, `docs/API_SPEC.md` (stub), and draft `docs/CLAUDE.md`  
- TODO markers + folder-level `_INSTRUCTIONS.md` files  

**Checklist**
- [ ] Frontend scaffold compiles (`npm run dev`)  
- [ ] Backend boots (`uvicorn backend.app.main:app --reload`)  
- [ ] Docs folder created with drafts (`REPO_MAP.md`, `API_SPEC.md`, `CLAUDE.md`)  
- [ ] TODO markers and `_INSTRUCTIONS.md` stubs in place  

---

## STEP 2 — Enrich the Scaffold
If the repo looks shallow, enrich it so Claude needs fewer leaps of imagination.  

Add:
- Sample frontend routes and components (`/`, `/about`, `/dashboard`)  
- Domain model stubs and types/interfaces  
- Mock data + fixtures for UI flows  
- README files with quick run instructions for both frontend and backend  
- Instructions embedded in folders (e.g. `CLAUDE_TASK: …`)

**Deliverables**
- Sample routes and pages (`/`, `/about`, `/dashboard`)  
- Domain model stubs and type definitions  
- Mock data and fixtures for UI flows  
- README files for frontend and backend with run instructions  
- Folder-level instructions (`_INSTRUCTIONS.md`)  

**Checklist**
- [ ] At least 2–3 sample routes/pages exist  
- [ ] Domain types/interfaces stubbed out  
- [ ] Mock data + fixtures included  
- [ ] README_FRONTEND.md and README_BACKEND.md added  
- [ ] Each folder has `_INSTRUCTIONS.md` where relevant 

---

## STEP 3 — Audit for Alignment
Check that the scaffold actually matches the product brief, tech specs, and UX goals.
Add additional UI/UX elements (if needed) to make the application visually appealing (and update the design requirements after that)

- Do navigation and pages reflect the product’s main flows?  
- Do API endpoints match the UI needs?  
- Is the chosen tech stack consistent (no unused or conflicting libraries)?  
- Is the UX direction reflected (design tokens, layout, component stubs)?

**Deliverables**
- Alignment review across Product ↔ UI/UX ↔ Tech  
- Identify any missing flows, mismatched libraries, or conflicting instructions  

**Checklist**
- [ ] Navigation structure matches product journeys  
- [ ] Components/pages map to required features  
- [ ] API endpoints cover MVP needs  
- [ ] No contradictory or unused technologies  

---

## STEP 4 — Document the Architecture
Now make the docs **Claude-ready**:

- **REPO_MAP.md**: Full repo breakdown with roles of each folder  
- **API_SPEC.md**: Endpoints, payloads, error handling  
- **CLAUDE.md**: Editing rules, coding conventions, AI collaboration guidelines  

These three files are the **context backbone** Claude will use to understand the repo.

**Deliverables**
- `REPO_MAP.md`: full repo breakdown with folder purposes  
- `API_SPEC.md`: endpoints, models, error conventions  
- `CLAUDE.md`: collaboration rules, editing boundaries  

**Checklist**
- [ ] REPO_MAP.md fully describes structure  
- [ ] API_SPEC.md covers all MVP endpoints and schemas  
- [ ] CLAUDE.md includes project overview, editing rules, examples  

---

## STEP 5 — Improve the Prompt
Enhance the prompt (in `docs/PROMPT_DECLARATION.md`) with details Claude needs:

- FE/BE boundaries and data contracts  
- UX guidelines (states, accessibility, interaction patterns)  
- Performance budgets (bundle size, API latency)  
- Security constraints (auth, rate limits, PII handling)  
- Testing expectations (unit, integration, end-to-end)

**Deliverables**
- FE/BE boundaries and contracts  
- UX guidelines (states, accessibility, patterns)  
- Performance budgets (bundle size, latency targets)  
- Security constraints (auth, PII, rate limits)  
- Testing expectations  

**Checklist**
- [ ] Prompt includes FE/BE division of responsibility  
- [ ] UX principles and design tokens specified  
- [ ] Performance/security/testing requirements added  
- [ ] Prompt is concrete and actionable for Claude  

---

## STEP 6 — Expert Audit of the Prompt
Now do a **meticulous audit** of the one-page prompt declaration.

- Add Frontend Architecture, Backend Architecture, Design requirements, Core Integrations, Success Criteria, Implementation Guidelines and Security & Compliance categories from this Project Brief to the prompt declaration.
- Remove inconsistencies, duplicates, or unused technologies  
- Ensure Tech Stack → Product → Scaffold alignment (no mismatches)  
- Add UI/UX details that make the product visually appealing and usable  
- Double-check frontend and backend folders are ready  
- Confirm editing boundaries are clear (what Claude can/can’t touch)  
- Make the declaration **battle-tested and handoff-ready**

**Deliverables**
- Remove inconsistencies/duplicates  
- Ensure stack ↔ product ↔ scaffold alignment  
- Add UI/UX and accessibility details  
- Clarify file boundaries (editable vs do-not-touch)  
- Confirm prompt uses Claude-friendly syntax  

**Checklist**
- [ ] No unused or contradictory tech remains  
- [ ] UI/UX directives are product-specific and sufficient  
- [ ] Editing boundaries explicitly defined  
- [ ] Prompt syntax uses clear, imperative instructions  

---

## STEP 7 — Bird’s-Eye Repo Review
Do a quick top-level scan for missing pieces:

- All folders contain either code or `_INSTRUCTIONS.md`  
- `.env.example` files exist for both frontend and backend  
- CI/CD config is present and not trivially broken  
- Run scripts (`npm run dev`, `uvicorn …`) work end-to-end  
- No orphan TODOs without clear ownership

**Deliverables**
- Verify all core files exist  
- Confirm environment, CI, and scripts work end-to-end  

**Checklist**
- [ ] Every folder has code or `_INSTRUCTIONS.md`  
- [ ] `.env.example` present for both frontend and backend  
- [ ] CI pipeline triggers and passes basic checks  
- [ ] Dev script (`scripts/dev.sh`) runs both FE and BE  

---

## STEP 8 — Finalize CLAUDE.md
This is where Claude gets its **onboarding pack**. Make sure `CLAUDE.md` includes:

- **Project Overview**: one-paragraph purpose, stack, goals, target users  
- **Folder & File Structure**: what’s editable vs do-not-touch  
- **Coding Conventions**: style guides, naming rules, commenting expectations  
- **AI Collaboration Rules**: response format, edit rules, ambiguity handling  
- **Editing Rules**: full-file vs patches, locked files  
- **Dependencies & Setup**: frameworks, services, env vars  
- **Workflow & Tools**: how to run locally, FE/BE boundary, deployment notes  
- **Contextual Knowledge**: product quirks, domain rules, business logic caveats  
- **Examples**: good vs bad AI answer

**Deliverables**
- Project overview (purpose, stack, goals, users)  
- Folder & file structure with editable vs do-not-touch  
- Coding conventions (style, naming, commenting)  
- AI collaboration rules (response style, edit rules, ambiguity handling)  
- Dependencies and setup instructions  
- Workflow, deployment notes, contextual knowledge  
- Good vs bad answer examples  
- Fill out all the missing information in the CLAUDE.md file

**Checklist**
- [ ] Project overview section filled in  
- [ ] File boundaries clearly defined  
- [ ] Coding/style conventions included  
- [ ] AI collaboration & editing rules written  
- [ ] Dependencies & env notes covered  
- [ ] Workflow & deployment info added  
- [ ] Contextual knowledge documented  
- [ ] Good vs bad examples included  
- [ ] CLAUDE.md file does not miss any important information

---

# ✅ Outcome
When this 8-step plan is followed:
- The repo is a **rich, opinionated scaffold** (80% done).  
- Docs give Claude **clear boundaries + context**.  
- The one-page prompt is **battle-tested** and aligned.  
- Claude Code can safely and efficiently generate the missing 20%.  






